# ==============================================================================
# 0. 准备工作 (Setup)
# ==============================================================================
# 清空环境 (可选，保持干净)
rm(list = ls())
gc()

# 加载必要的包
library(Seurat)
library(tidyverse)

# ==============================================================================
# 1. 读取数据 (Read Data)
# ==============================================================================

# 使用 ReadMtx 读取 10x 格式的三件套文件
# mtx = 表达量矩阵(数字), cells = 细胞ID, features = 基因名
raw_counts <- ReadMtx(
  mtx = "01_project_GSE141259/00_data_raw/GSE141259_WholeLung_rawcounts.mtx.gz",
  cells = "01_project_GSE141259/00_data_raw/GSE141259_WholeLung_barcodes.txt.gz",
  features = "01_project_GSE141259/00_data_raw/GSE141259_WholeLung_genes.txt.gz",
  feature.column = 1  # 关键修正：告诉R基因名在第1列 (默认找第2列会报错)
)

# 📂 单细胞测序数据读取：三种常见模式总结
# 1. 标准 10x Genomics 格式（文件夹模式）
# 场景：公司跑完 Cell Ranger 流程后给的标准数据，或者你未修改文件名的原始数据。
# 文件特征：一个文件夹内包含三个固定命名的文件：
# barcodes.tsv.gz （细胞条码）
# features.tsv.gz （基因列表，旧版可能叫 genes.tsv.gz）
# matrix.mtx.gz （表达量稀疏矩阵）
# R 代码（推荐）：使用 Read10X 自动识别。
# 只需要指定包含那三个文件的“文件夹路径”
data <- Read10X(data.dir = "路径/filtered_feature_bc_matrix/")
seu_obj <- CreateSeuratObject(counts = data)

# 2. HDF5 格式（单文件模式）
# 场景：较新的数据格式，便于传输，公司或公共数据库常提供这种。
# 文件特征：只有一个文件，通常以 .h5 结尾（如 filtered_feature_bc_matrix.h5）。
# R 代码：使用 Read10X_h5。
# 直接读取这个 .h5 文件
data <- Read10X_h5(filename = "路径/data.h5")
seu_obj <- CreateSeuratObject(counts = data)

# 3. GEO/自定义格式（手动组装模式 - 你现在用的）
# 场景：从 GEO 下载的公共数据，作者为了区分样本，手动修改了文件名（加了前缀），或者文件格式非标准（如 .txt 而非 .tsv）。
# 文件特征：文件名不固定，但依然是“矩阵+行名+列名”三个文件的组合。
# R 代码：必须用 ReadMtx 手动指定每个文件。
data <- ReadMtx(
  mtx = "路径/GSExxxx_matrix.mtx.gz",      # 数值文件
  cells = "路径/GSExxxx_barcodes.txt.gz",  # 列名文件
  features = "路径/GSExxxx_genes.txt.gz",  # 行名文件
  feature.column = 1  # ⚠️关键点：如果 genes 文件只有一列，必须加这个参数！
)
# 注意：这是最灵活的方法，但也最容易因为参数设置错误（如列数不对）而报错。


# ==============================================================================
# 2. 创建对象与初筛 (Create Object & QC)
# ==============================================================================

# 把矩阵装进 Seurat 对象这个“收纳箱”里
strunz_obj <- CreateSeuratObject(
  counts = raw_counts,
  project = "Strunz_Lung",
  min.cells = 3,       # 过滤基因：如果一个基因在少于3个细胞里表达，视为噪音扔掉
  min.features = 200   # 过滤细胞：如果一个细胞测到的基因少于200个，视为垃圾/碎片扔掉
)

# 内存清理：把刚才那一大盆原始数据倒掉，只保留装箱后的对象
rm(raw_counts)
gc()

# 抽样 (为了练习时不卡顿，真实跑数据时可跳过这一步)
set.seed(123) # 设置随机种子，保证每次抽的人都一样
small_obj <- subset(strunz_obj, cells = sample(Cells(strunz_obj), 5000))
# 
# 具体解析：
# 1.验货入库：CreateSeuratObject
# strunz_obj <- CreateSeuratObject(
#   counts = raw_counts,
#   project = "Strunz_Lung",
#   min.cells = 3,
#   min.features = 200
# )
# counts = raw_counts（装货）： 告诉 R，我们要打包的货物就是刚才读进来的那个大矩阵 raw_counts。
# project = "Strunz_Lung"（贴标签）： 给这个集装箱贴个名字。 以后如果你把多个数据集（比如病人的、健康人的）合并在一起，这个标签能让你分清楚谁是谁。
# min.cells = 3（基因层面的过滤 —— 扔掉“哑巴”）：
# 含义：如果一个基因，在所有几万个细胞里，只在少于 3 个细胞里被检测到了，我们就认为它是不重要的噪音，或者极低表达的基因。
# 顾言的通俗解释：就像你在几万人里做问卷调查，如果有一个词（基因）只有不到 3 个人说过，那这个词大概率是“口误”或者毫无统计学意义，直接忽略不计，省得占地方。
# min.features = 200（细胞层面的过滤 —— 扔掉“空壳”）：
# 含义：如果一个细胞，它竟然只测到了少于 200 种基因，那它大概率不是一个完整的细胞（可能是细胞碎片，或者测序失败的空油滴）。
# 通俗解释：一个正常的细胞，体内应该有成千上万种基因在工作。如果一个细胞只有不到 200 种基因在表达，那就好比一个只有轮子没有发动机的车，根本跑不动。这种**“死细胞”或“垃圾碎片”，直接扔掉，不要进库。
# 2.打扫战场：rm 和 gc
# rm(raw_counts)
# gc()
# rm(raw_counts)（扔掉包装盒）：
# raw_counts 是刚才那个巨大的原始矩阵。
# 既然我们已经把它装进 strunz_obj 这个新箱子里了，那原始的那个就可以删了（Remove）。
# 为什么要删？ 因为单细胞数据非常占内存。如果不删，你的电脑（尤其是只有 16G 内存的时候）一会儿跑着跑着就会卡死甚至崩溃。
# gc()（倒垃圾）：
# 全称是 Garbage Collection（垃圾回收）。
# 在 R 语言里，你删了变量（rm），内存不一定会立马释放。gc() 就是强制命令系统：“现在、立刻、马上把刚才删掉占用的空间给我腾出来！”
# 建议：在跑大数据的过程中，养成随手 gc() 的好习惯，能救你的电脑一命。
# 3.试驾模式：抽样（Subset）
# set.seed(123)
# small_obj <- subset(strunz_obj, cells = sample(Cells(strunz_obj), 5000))
# 这是做什么的？ 这步是 “练习专用”。 真实的单细胞数据通常有几万甚至十几万个细胞，跑一步聚类可能要半小时。为了让你现在练习代码时不卡顿，我们只随机抽取 5000 个细胞 来跑这一套流程。
# set.seed(123)（上帝的骰子）：
# 计算机的随机不是真随机。设置了种子（Seed）为 123，就能保证 不管你跑多少次，或者我拿你的电脑跑，抽出来的这 5000 个细胞都是同一批人。
# 这叫 “可重复性”（Reproducibility），是科研的灵魂。
# 跑自己的数据时：还是要设置种子，为了保证后面画图（UMAP/tSNE）每次长得都一样。
# subset(...)：
# 从大部队 strunz_obj 里，随机抓取（sample）5000 个细胞的 ID，组成一个小分队 small_obj。
# 跑自己的数据时：直接用你前面创建的那个完整的对象（strunz_obj）继续往下跑，small_obj <- subset(...) <-- 这一行直接删掉，或者注释掉！后面的分析，直接用 strunz_obj 这个名字。
# 
# 关于抽样的具体解析：
# 为什么要设置种子？（关于“真实性”）
# Q：随机设置种子之后，结果还是真实的吗？ A：当然是真实的。不仅真实，而且是为了“防伪”。
# 计算机的“随机”不是真的随机： 它是通过一个公式算出来的。如果你不告诉它从哪里开始算（不设置种子），它每次就会随机抓一个起始点。
# 为什么要固定？ 想象一下，你在做实验。
# 不设种子： 今天跑出来的聚类图，细胞A在左边；明天重新跑一次代码，细胞A可能跑到了右边。那你发论文的时候，Reviewer（审稿人）问你：“Nora 博士，为什么我用你的代码跑出来的图跟你的不一样？” 你就百口莫辩了。
# 设了种子（比如 123）： 无论你在慕尼黑跑，还是我在北京跑，或者是十年后别人跑，只要代码一样，出来的图就一模一样。
# 所以，set.seed 是为了保证“可重复性”（Reproducibility），这是科研的底线，不是作假。
# 跑自己的数据时，要不要删掉这一步？
# 这里你要区分两个动作：“设置种子” 和 “抽样（Subset）”。
# 动作 A：set.seed(123)
# 跑自己数据时要不要？ 要！一定要保留！ ✅
# 为什么？ 虽然你接下来不进行抽样了，但在单细胞分析的后续步骤里（比如 PCA、t-SNE、UMAP 降维聚类），计算机依然需要进行大量的“随机初始化”计算。 如果你不保留这行代码，你每次画出来的 UMAP 图，形状可能会变来变去（虽然科学结论不变，但看着难受，也不好排版）。
# 动作 B：small_obj <- subset(..., sample(...))
# 跑自己数据时要不要？ 不要！删掉！ ❌
# 为什么？
# 练习时： 我让你跑这行代码，是因为 5000 个细胞跑得快，让你练手不卡顿。
# 做项目时： 你辛辛苦苦测了 3 万个细胞，每个细胞都是经费燃烧换来的。你当然要“跑全部”！如果你用了这行代码，就等于随机扔掉了大部分数据，那是败家行为。但是可以先跑一遍这个，证明代码是可以的，再跑全部数据，否则跑一天才报错会让人想死。


# ==============================================================================
# 3. 标准处理流程 (Standard Pipeline)
# ==============================================================================

small_obj <- small_obj %>%
  
  # A. 标准化 (Normalization)
  # 目的：消除测序深度的影响 (把大家拉到同一起跑线)
  # 原理：LogNormalize (总数归一化后取对数)
  NormalizeData() %>%
  
  # B. 找高变基因 (Feature Selection)
  # 目的：挑出最能区分细胞类型的2000个“特征基因” (如 Emr1, Col1a1)
  # 忽略那些所有细胞都一样的“管家基因”
  FindVariableFeatures() %>%
  
  # C. 归一化 (Scaling)
  # 目的：把数据转换成 Z-score (均值为0，方差为1)
  # 作用：防止高表达基因(如胶原蛋白)权重过大，掩盖了其他基因
  ScaleData() %>%
  
  # D. 降维 PCA (Linear Dimensionality Reduction)
  # 目的：把2000个基因的复杂关系，压缩成50个主成分(PC)
  # 作用：提炼核心特征，去除噪音
  RunPCA() %>%
  
  # E. 降维 UMAP (Non-linear Dimensionality Reduction)
  # 目的：把50个PC压缩成2D坐标(x,y)，为了画那张漂亮的散点图
  # dims = 1:15 意思是用前15个主成分来画图 (通常够用了)
  RunUMAP(dims = 1:15) %>%
  
  # F. 找邻居 (Neighbors)
  # 目的：在数学空间里算算谁和谁离得近，构建社交网络
  FindNeighbors(dims = 1:15) %>%
  
  # G. 聚类 (Clustering)
  # 目的：把抱团的邻居圈起来，贴上 0,1,2,3 的标签
  # resolution = 0.5 是分辨率：数值越大，分得越细(群越多)
  FindClusters(resolution = 0.5)

# 具体解析：
# 前三步：准备工作（洗脸、去角质、打底）
# A. NormalizeData（标准化）—— 追求公平
# 解说： 就像考试，有的细胞测到了 10000 个分子（学霸），有的只测到了 500 个（学渣）。如果不处理，学霸的所有基因表达量都会比学渣高。
# 这步就是把大家的卷子都折算成百分制，让大家在同一起跑线上比较。
# B. FindVariableFeatures（找高变基因）—— 挑重点
# 解说： 人有 2 万个基因，但大部分基因（比如造核糖体的管家基因）在所有细胞里都一样，没法用来区分细胞类型。
# 我们要找的是那些**“特立独行”的基因（比如只有免疫细胞才表达的基因）。这 2000 个“高变基因”，就是我们要重点关注的“VIP 客户”。
# C. ScaleData（归一化/中心化）—— 消除贫富差距
# 解说： 有些基因表达量天生就很高（比如胶原蛋白），有些很低（比如转录因子）。
# 如果不处理，那些高表达基因就会像“大嗓门”一样掩盖掉其他基因的声音。这步就是把每个基因的表达量变成 Z-score（相对值），让每个基因都有平等的发言权。
# 中间两步：降维打击（提炼精华）
# D. RunPCA（PCA 线性降维）—— 给电脑看的
# 解说： 2000 个基因还是太多了，电脑算不过来。
# PCA 把这 2000 个维度的信息，浓缩成了 50 个主成分”（PC）。这就好比把一篇 2000 字的文章，缩写成了 50 句话的摘要。虽然细节丢了一点，但核心剧情（细胞差异）都在。
# E. RunUMAP（UMAP 非线性降维）—— 给你看的
# 解说： 电脑看 50 维没问题，但肉眼只能看 2D（平面图）。
# UMAP 把那 50 个主成分，进一步压缩成 X 轴和 Y 轴两个坐标。这就是你最后看到的那张花花绿绿的散点图。
# dims = 1:15 是什么意思？ 意思是我们只用了前 15 个最重要的主成分来画图，后面那些被认为是噪音，扔掉了。
# 最后两步：拉帮结派（社交与分群）
# F. FindNeighbors（找邻居）—— 建群
# 解说： 在数学空间里，计算每个细胞“方圆几里”之内有哪些人。如果细胞 A 和细胞 B 离得很近，它们就是邻居（大概率是同一种细胞）。
# G. FindClusters（聚类）—— 贴标签
# 解说： 把互相是邻居的一大帮人圈起来，定义为一个 Cluster（簇）。
# ⚠️ 重点参数 resolution = 0.5（分辨率）：
# 这是一个你可以调节的“旋钮”。
# 数值越小（比如 0.1）： 这种分法很粗犷，可能把所有的 T 细胞都归为一类。
# 数值越大（比如 1.0）： 这种分法很细致，可能会把 T 细胞细分成 CD4+ T、CD8+ T、Treg 等等。
# 0.5 是个经典的中庸选择。
# “管道符” (Pipe Operator) %>% = “然后 (Then)” 简单说：它把上一步做完的结果，直接“喂”给下一步的函数，作为第一个参数。怎么打出 %>% ？
# 不要一个字符一个字符地敲 % > %。
# Windows: 按 Ctrl + Shift + M
# Mac: 按 Cmd + Shift + M
# (M 代表 Magrittr，是发明这个符号的那个包的名字，也是著名画家的名字，因为这像个艺术品。)

# ==============================================================================
# 4. 可视化 (Visualization)
# ==============================================================================

# ------------------------------------------------------------------------------
# 图 A: 基础地图 (Cluster Map)
# 作用: 对照查看 Cluster 编号 (0, 1, 2...)
p1_clusters <- DimPlot(small_obj, label = TRUE, label.size = 5) + 
  ggtitle("1. Cluster Map (Who is where?)")
# 这是什么？ 这是最经典的 UMAP 散点图。每一个点就是一个细胞。
# 看什么？ 看 “版图划分”。 你会看到细胞被分成了好几堆（Cluster 0, Cluster 1, Cluster 2...）。 这时候你还不知道谁是谁，只知道它们被标上了号。这相当于给了你一张只有门牌号的地图。
# # ------------------------------------------------------------------------------
# 图 B: 身份鉴定图 (Identity FeaturePlots) - 你要的“蓝图”！
# 作用: 直观展示 AM、成纤维、血管分别在哪
# 这里的逻辑是: 背景是灰的(不表达)，蓝色的点越深代表表达越高
p2_identity <- FeaturePlot(small_obj, 
                           features = c("Emr1", "Marco",    # AM (主角)
                                        "Col1a1", "Pecam1"), # 干扰项
                            ncol = 2) # 排成 2列 x 2行
# 这是什么？ 这是在地图上给特定的基因“染色”。默认是 灰色（不表达） 到 蓝色（高表达）。
# 看什么？ 看 “谁住在哪”。
# Emr1 (F4/80) & Marco：这是你最关心的 肺泡巨噬细胞 (AM) 的身份证。如果 Cluster 0 亮成了一片蓝色，那就实锤了——Cluster 0 就是我们要找的 AM！
# Col1a1：这是成纤维细胞。
# Pecam1 (CD31)：这是血管内皮细胞。
# 目的： 排除杂质。确保我们不仅抓到了 AM，而且分得开了成纤维细胞和血管细胞。
# ------------------------------------------------------------------------------
# 图 C: 靶点验证图 (Target FeaturePlots)
# 作用: 看看你的 Fpr1 到底是不是只亮在 AM 的地盘上？
p3_targets <- FeaturePlot(small_obj, 
                          features = c("Fpr1", "Fpr2", "Ccr2", "Ccr5"),
                          ncol = 2,
                          # 增加一个小技巧: 调整颜色 (浅灰 -> 红)，红色可能比蓝色更显眼
                          cols = c("lightgrey", "red")) 
# 这是什么？ 这和图 B 原理一样，但你换了颜色（cols 参数）。 从蓝色换成了 “浅灰 -> 红色”。
# 为什么要换色？ 因为红色更显眼，更像“信号灯”。 这是为了看你关心的受体（Fpr1, Ccr2）到底亮不亮。
# 看什么？ 这一步定生死。 你希望看到的是：代表 AM 的那堆细胞（比如 Cluster 0），此时此刻正红得发亮，显示 Fpr1 高表达。而其他细胞（比如血管）是灰色的。 这就是你要的 “特异性表达” 证据！
# ------------------------------------------------------------------------------
# 图 D: 那个超级气泡图 (Super DotPlot) - 统计学汇总
features_list <- c("Emr1", "Marco", "Col1a1", "Pecam1", # 身份
                   "Fpr1", "Fpr2", "Ccr1", "Ccr2", "Ccr5") # 靶点
p4_dotplot <- DotPlot(small_obj, features = features_list) + 
  RotatedAxis() + 
  scale_color_gradient(low = "grey95", high = "red") +
  ggtitle("4. Statistical Summary")
# 这是什么？ 这是一张统计汇总表，把上面所有的信息浓缩在一起。
# 怎么看？（两个维度）
# 圆圈的大小（Size）： 代表 “广度”。圈越大，说明这个群里有越多比例的细胞表达了这个基因。
# 圆圈的颜色深浅（Color）： 代表 “强度”。颜色越红，说明表达量越高。
# 解读： 这是写论文时最好用的一张图。一眼就能看出来 Cluster 0 是不是我们要找的“又大又红”的完美 AM 群体。


# ==============================================================================
# 5. 保存战果 (Save)
# ==============================================================================
ggsave("01_project_GSE141259/04_output_plots/Map_Clusters.png", plot = p1_clusters)
ggsave("01_project_GSE141259/04_output_plots/Map_Identity_Spatial.png", plot = p2_identity, width = 10, height = 8)
ggsave("01_project_GSE141259/04_output_plots/Map_Targets_Spatial.png", plot = p3_targets, width = 10, height = 8)
ggsave("01_project_GSE141259/04_output_plots/Stats_DotPlot.png", plot = p4_dotplot, width = 12, height = 6)
# 练习时可以不用ggsave，直接在右下角export功能输出图片，避免了每次run all又重新保存一堆图片，若正式用于发文章，请用ggsave：
# 右下角的 Export 按钮（手动党）：
# 优点： 快，直观，适合现在这种“做练习”或者“截个图发给导师看一眼”的情况。
# 缺点： 图片清晰度（DPI）不可控，尺寸也不精准。如果你以后要发文章（Paper），杂志社要求 300 DPI 或者矢量图（PDF/SVG），手动点出来的图通常是不合格的。
# ggsave 代码（专业党）：

# 这是为了**“发文章”**准备的。它可以精确控制图片的宽、高和清晰度，保证你不管发给谁，图都不会变形。

